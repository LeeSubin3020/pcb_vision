PCB Vision 프로젝트 오류 수정 및 변경 사항 요약
================================================

안녕하세요! 이 파일은 PCB Vision 프로젝트의 오류를 해결하면서 적용된 주요 변경 사항들을 학습 목적으로 요약한 것입니다.

총 3단계에 걸쳐 문제가 해결되었습니다.

---

### 1단계: 모델 추론 결과 접근 오류 수정

*   **문제점:**
    가장 처음 발생했던 `Index was outside the bounds of the array` 오류는 `PcbModel.cs` 파일에서 발생했습니다. ONNX 모델이 추론을 통해 내보낸 결과 데이터(Tensor)에 접근할 때, 데이터의 차원(dimension)을 잘못 해석하여 존재하지 않는 인덱스에 접근하려고 시도했기 때문입니다.
    *   모델 출력 데이터는 `[배치, 채널, 제안]` 형태인데, 코드에서는 `[배치, 제안, 채널]` 형태로 잘못 접근하고 있었습니다. (예: `outputTensor[0, i, 0]` -> `i`가 채널의 크기를 넘어감)

*   **해결책:**
    데이터 접근 순서를 `outputTensor[0, 채널_인덱스, 제안_인덱스]` 형태로 올바르게 수정하여, 각 데이터에 정상적으로 접근할 수 있도록 했습니다. (예: `outputTensor[0, 0, i]`)

---

### 2단계: 'White Balance' 필터 오류 수정

*   **문제점:**
    1단계 수정 후에도 동일한 오류가 발생했지만, 디버깅 결과 이번에는 모델 추론이 시작되기도 전에 오류가 발생하는 것을 확인했습니다. 원인은 `MainPresenter.cs`의 'White Balance' 필터 로직에 있었습니다.
    *   카메라가 흑백(1채널) 이미지를 전송하는 경우, 코드는 이 이미지를 3채널(BGR)로 간주하고 강제로 채널을 분리(`_frame.Split()`)하려고 했습니다. 1채널 이미지를 3개로 나누려고 하니, 존재하지 않는 두 번째(`bgr[1]`) 또는 세 번째(`bgr[2]`) 채널에 접근하면서 `Index was outside the bounds of the array` 오류가 발생했습니다.

*   **해결책:**
    'White Balance' 필터를 적용하기 전에, 입력된 이미지(`_frame`)가 1채널인지 확인하는 코드를 추가했습니다. 만약 1채널이면, 3채널 BGR 이미지로 자동 변환(`Cv2.CvtColor`)한 후에 필터 로직을 실행하도록 하여 오류를 해결했습니다.

---

### 3단계: 모델-코드 간 근본적 불일치 해결 (YOLOv8 형식 적용)

*   **문제점:**
    모든 수정 후에도 `session.Run()`이라는 ONNX 런타임 핵심 메소드에서 동일한 오류가 발생했습니다. 이는 사용자가 클래스 수를 9개에서 4개로 변경하면서 도입한 새 모델과, 이 모델의 결과를 해석하는 C# 코드 사이에 근본적인 구조적 불일치가 있음을 의미했습니다.
    *   기존 코드는 '객체 신뢰도(Object Confidence)' 점수가 별도로 존재하는 **YOLOv5 스타일**의 출력 형식을 가정하고 있었습니다. (`x, y, w, h, obj_conf, class1, ...`)
    *   하지만 새로 도입된 모델은 **표준 YOLOv8 스타일**, 즉 별도의 신뢰도 점수 없이 `x, y, w, h` 좌표 뒤에 바로 클래스별 확률이 나오는 출력 형식(`x, y, w, h, class1, class2, ...`)을 가질 가능성이 높았습니다. 이 구조적 차이 때문에 ONNX 런타임이 모델을 실행하는 단계에서 내부적으로 충돌을 일으킨 것입니다.

*   **해결책:**
    `PcbModel.cs`의 모델 결과 처리 로직 전체를 표준 4클래스 YOLOv8 모델의 출력 형식에 맞게 재작성했습니다.
    *   출력 채널을 8개(`x,y,w,h` + 4개 클래스 확률)로 가정합니다.
    *   별도의 '객체 신뢰도'를 사용하지 않고, 여러 클래스 확률 중 가장 높은 값을 최종 신뢰도(`confidence`)로 사용하도록 변경했습니다.
    *   이로써 모델이 실제로 출력하는 데이터 구조와 코드가 데이터를 해석하는 방식이 일치하게 되어, 마침내 모든 오류가 해결되었습니다.

---

이 과정을 통해 우리는 표면적인 오류 수정에서 시작하여, 데이터 처리 흐름을 추적하고, 최종적으로는 시스템의 핵심 구성요소(모델과 코드) 간의 근본적인 불일치를 찾아 해결할 수 있었습니다.
